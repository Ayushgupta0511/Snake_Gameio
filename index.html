<!--
index.html
Single-file Snake game (HTML + CSS + JS).
Visual style: neon-green grid, glowing snake, red apple, centered "digital display".
Controls: Arrow keys (desktop/laptop).
No external libraries.
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Neon Snake — TEAM: J PRO</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    /* ===========================
       Page & Container layout
       =========================== */
    :root{
      --bg:#050607;
      --panel:#081012;
      --neon-green:#0ff07a;
      --neon-green-2:#00f26a;
      --neon-outline: rgba(0,255,140,0.12);
      --glass: rgba(255,255,255,0.03);
      --accent:#ff2b2b;
      --hud-height:96px;
      --max-width:980px;
    }

    html,body{
      height:100%;
      margin:0;
      background:
        radial-gradient(1200px 700px at 10% 10%, rgba(0,100,60,0.04), transparent 8%),
        radial-gradient(900px 500px at 90% 90%, rgba(0,200,120,0.02), transparent 8%),
        var(--bg);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color: #cfeee0;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:28px;
      box-sizing:border-box;
    }

    /* Centered digital display */
    .display {
      width: min(94vw, var(--max-width));
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
      border-radius:16px;
      padding:18px;
      box-shadow:
        0 8px 30px rgba(0,0,0,0.8),
        0 0 40px rgba(0,255,140,0.04) inset;
      border: 1px solid rgba(0,255,140,0.06);
      display:flex;
      gap:18px;
      align-items:flex-start;
      justify-content:center;
      flex-direction:column;
    }

    /* Header with logo placeholder and team text */
    header.topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:6px 12px;
    }
    .logo {
      display:flex;
      align-items:center;
      gap:10px;
    }
    .logo .badge {
      width:72px;
      height:48px;
      background: linear-gradient(135deg, rgba(0,255,140,0.12), rgba(0,255,140,0.04));
      border-radius:8px;
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--neon-green);
      font-weight:700;
      letter-spacing:0.6px;
      font-size:14px;
      box-shadow: 0 0 18px rgba(0,255,140,0.08);
      border:1px solid rgba(0,255,140,0.09);
    }
    .meta {
      color:#9fe4c9;
      font-size:13px;
      font-weight:600;
      letter-spacing:0.6px;
    }

    /* Main content layout: left = game canvas, right = HUD */
    .main {
      display:flex;
      gap:18px;
      align-items:flex-start;
      justify-content:center;
      width:100%;
    }

    /* Game card (digital screen) */
    .game-card {
      flex:1 1 640px;
      min-width:280px;
      max-width:720px;
      background: linear-gradient(180deg, rgba(0,0,0,0.24), rgba(0,0,0,0.12));
      border-radius:12px;
      padding:14px;
      box-shadow: 0 6px 30px rgba(0,0,0,0.6), 0 0 28px rgba(0,255,140,0.02) inset;
      border: 1px solid rgba(0,255,140,0.06);
      display:flex;
      flex-direction:column;
      align-items:center;
    }

    /* Canvas wrapper for neon frame */
    .screen {
      width:100%;
      aspect-ratio: 4/3;
      max-height:640px;
      display:grid;
      place-items:center;
      padding:12px;
      box-sizing:border-box;
      background:
        linear-gradient(0deg, rgba(0,0,0,0.15), rgba(0,0,0,0.02));
      border-radius:10px;
      position:relative;
      overflow:hidden;
      /* subtle neon frame */
      box-shadow:
        0 0 30px rgba(0,255,140,0.04),
        0 0 4px rgba(0,200,100,0.06) inset;
      border: 1px solid rgba(0,255,140,0.06);
    }

    /* canvas will fill available area while keeping pixel-perfect grid */
    canvas#gameCanvas {
      width:100%;
      height:100%;
      display:block;
      border-radius:6px;
      background: repeating-linear-gradient(
        0deg,
        rgba(0,0,0,0) 0px,
        rgba(0,0,0,0) 28px,
        rgba(0,255,140,0.02) 29px
      );
      image-rendering: auto;
      box-shadow:
        0 0 40px rgba(0,255,140,0.06) inset,
        0 0 12px rgba(0,255,140,0.03);
    }

    /* Neon grid overlay style (painted by canvas too but add soft glow around) */
    .grid-glow {
      position:absolute;
      inset:12px;
      pointer-events:none;
      border-radius:8px;
      box-shadow: 0 0 80px rgba(0,255,140,0.04);
      mix-blend-mode: screen;
    }

    /* HUD / controls panel on right */
    .hud {
      width:260px;
      min-width:200px;
      max-width:320px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.05));
      border-radius:10px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:stretch;
      justify-content:flex-start;
      border:1px solid rgba(0,255,140,0.04);
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    }

    .hud .title {
      font-weight:700;
      color:var(--neon-green);
      letter-spacing:0.6px;
      font-size:15px;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .stat {
      background: linear-gradient(90deg, rgba(0,255,140,0.02), rgba(0,0,0,0.03));
      padding:10px;
      border-radius:8px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      border: 1px solid rgba(0,255,140,0.03);
    }
    .stat .label { color:#9fe4c9; font-size:13px; }
    .stat .value { color: #eafff0; font-weight:800; font-size:16px; }

    /* buttons */
    .controls {
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    .btn {
      flex:1 1 48%;
      background:linear-gradient(180deg, rgba(0,255,140,0.04), rgba(0,255,140,0.01));
      color:var(--neon-green);
      border-radius:8px;
      padding:8px 10px;
      font-weight:700;
      text-align:center;
      cursor:pointer;
      border:1px solid rgba(0,255,140,0.06);
      transition:transform .08s ease, box-shadow .08s ease;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px) }
    .btn.secondary {
      background: linear-gradient(180deg, rgba(255,0,60,0.02), rgba(0,0,0,0.02));
      color:var(--accent);
      border:1px solid rgba(255,0,60,0.05);
    }

    /* small footer note */
    .note { color:#89e0b8; font-size:12px; opacity:0.9; text-align:center; padding-top:6px; }

    /* Responsive tweaks */
    @media (max-width:880px){
      .main { flex-direction:column; align-items:center; }
      .hud { width:100%; max-width:640px; }
      .game-card { width:100%; }
    }

    /* Neon text effect for game title overlay (optional small flair) */
    .neon-title {
      position:absolute;
      left:12px;
      top:10px;
      font-weight:900;
      color:var(--neon-green);
      font-size:12px;
      text-shadow:
        0 0 8px rgba(0,255,140,0.12),
        0 0 28px rgba(0,255,140,0.04);
      letter-spacing:1.1px;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div class="display" role="application" aria-label="Neon Snake game">
    <!-- Header -->
    <header class="topbar">
      <div class="logo" aria-hidden="true">
        <div class="badge">NIET</div>
        <div class="meta">NEON SNAKE</div>
      </div>
      <div class="meta">TEAM: J PRO</div>
    </header>

    <div class="main">
      <!-- Game area -->
      <section class="game-card" aria-label="Game screen">
        <div class="neon-title">NEON GRID</div>
        <div class="screen">
          <!-- canvas draws grid, snake, and apple -->
          <canvas id="gameCanvas" tabindex="0" aria-label="Snake game canvas"></canvas>
          <div class="grid-glow" aria-hidden="true"></div>
        </div>
        <div class="note">Use Arrow Keys to play • P to Pause • M to Toggle Wrap</div>
      </section>

      <!-- HUD / stats & controls -->
      <aside class="hud" aria-label="Game controls and stats">
        <div class="title">
          <span>GAME INFO</span>
          <span style="font-size:12px;color:#89e0b8">NEON MODE</span>
        </div>

        <div class="stat"><div class="label">Score</div><div class="value" id="score">0</div></div>
        <div class="stat"><div class="label">Level</div><div class="value" id="level">1</div></div>
        <div class="stat"><div class="label">Speed</div><div class="value" id="spd">Normal</div></div>
        <div class="stat"><div class="label">Wrap</div><div class="value" id="wrap">OFF</div></div>

        <div class="controls">
          <div class="btn" id="btnStart">Start</div>
          <div class="btn secondary" id="btnPause">Pause</div>
          <div class="btn" id="btnWrap">Toggle Wrap</div>
          <div class="btn secondary" id="btnReset">Reset</div>
        </div>

        <div style="height:6px"></div>
        <div style="font-size:12px;color:#9fe4c9">Tip: Hold arrow to quickly change direction; game adapts to window size.</div>
      </aside>
    </div>
  </div>

  <script>
    /*
      Neon Snake - JavaScript
      - Canvas-based smooth snake with glowing trail
      - Responsive grid, arrow key controls
      - Comments explain each part
    */

    // ----- Configuration -----
    const config = {
      baseCells: 24,          // reference number of cells (square-ish grid) on the short side
      initialLength: 4,
      speedBase: 10,          // base frames-per-second; higher = faster
      speedIncreasePerLevel: 1.25,
      scorePerFood: 10,
      appleRadiusPct: 0.42,   // apple size relative to cell size
      trailFade: 0.12,        // canvas trail alpha per frame for glow tail
      cellGap: 1.2,           // gap between cells (visual grid spacing)
    };

    // ----- Canvas & rendering setup -----
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // opaque for better performance
    let DPR = Math.max(1, window.devicePixelRatio || 1);

    // Game runtime state
    let state = {
      cols: 32,
      rows: 24,
      cellSize: 20,
      snake: [],               // array of {x, y} with floats for smooth movement
      dir: { x: 1, y: 0 },     // current grid direction
      nextDir: { x: 1, y: 0 }, // buffered direction from input
      apple: null,             // {x, y}
      running: false,
      paused: false,
      wrap: false,
      speed: config.speedBase,
      score: 0,
      level: 1,
      frameAccumulator: 0,
      lastTime: 0,
    };

    // UI references
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const spdEl = document.getElementById('spd');
    const wrapEl = document.getElementById('wrap');
    const btnStart = document.getElementById('btnStart');
    const btnPause = document.getElementById('btnPause');
    const btnWrap = document.getElementById('btnWrap');
    const btnReset = document.getElementById('btnReset');

    // Utility: clamp integer
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    // ---------- Responsive grid calculation ----------
    function resizeCanvasToContainer() {
      // Determine available drawing area from element size
      const rect = canvas.getBoundingClientRect();
      DPR = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.round(rect.width * DPR);
      canvas.height = Math.round(rect.height * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

      // Choose grid size based on short side: keep cells square
      const availableW = rect.width;
      const availableH = rect.height;
      // Use config.baseCells on smaller dimension, scale other accordingly
      const shortSide = Math.min(availableW, availableH);
      const cells = Math.max(12, Math.round(shortSide / (shortSide / config.baseCells)));
      // Use columns proportional to aspect ratio of canvas
      const aspect = availableW / availableH;
      state.rows = cells;
      state.cols = Math.max(12, Math.round(cells * aspect));
      // Compute cell size fitting into canvas while leaving small padding
      const cellW = availableW / state.cols;
      const cellH = availableH / state.rows;
      state.cellSize = Math.floor(Math.min(cellW, cellH) - config.cellGap);
      // Recenter grid offsets
      state.offsetX = (availableW - (state.cols * (state.cellSize + config.cellGap))) / 2;
      state.offsetY = (availableH - (state.rows * (state.cellSize + config.cellGap))) / 2;
    }

    // ---------- Game initialization ----------
    function resetGame() {
      resizeCanvasToContainer();
      state.snake = [];
      // Place snake in center moving to the right, use float positions for smoothness
      const startX = Math.floor(state.cols / 2);
      const startY = Math.floor(state.rows / 2);
      for (let i = 0; i < config.initialLength; i++) {
        state.snake.push({ x: startX - i, y: startY });
      }
      state.dir = { x: 1, y: 0 };
      state.nextDir = { x: 1, y: 0 };
      state.apple = randomEmptyCell();
      state.running = false;
      state.paused = false;
      state.wrap = false;
      state.speed = config.speedBase;
      state.score = 0;
      state.level = 1;
      updateHUD();
      clearCanvasFull();
      drawGridBackground();
    }

    // ---------- Helper: get random empty cell ----------
    function randomEmptyCell() {
      // Build quick occupancy map of snake positions
      const occ = new Set(state.snake.map(p => `${p.x}|${p.y}`));
      const free = [];
      for (let y = 0; y < state.rows; y++) {
        for (let x = 0; x < state.cols; x++) {
          const key = `${x}|${y}`;
          if (!occ.has(key)) free.push({ x, y });
        }
      }
      if (free.length === 0) return { x: 0, y: 0 };
      return free[Math.floor(Math.random() * free.length)];
    }

    // ---------- Input handling ----------
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp') setNextDir(0, -1);
      if (e.key === 'ArrowDown') setNextDir(0, 1);
      if (e.key === 'ArrowLeft') setNextDir(-1, 0);
      if (e.key === 'ArrowRight') setNextDir(1, 0);
      if (e.key === 'p' || e.key === 'P') togglePause();
      if (e.key === 'm' || e.key === 'M') toggleWrap();
      if (e.key === ' ' && !state.running) startGame();
      if (e.key === 'r' || e.key === 'R') { resetGame(); }
    });

    function setNextDir(x, y) {
      // Prevent reversing direction directly
      if (x === -state.dir.x && y === -state.dir.y) return;
      state.nextDir = { x, y };
      // Start game on first direction input
      if (!state.running) startGame();
    }

    // ----- Control button events -----
    btnStart.addEventListener('click', startGame);
    btnPause.addEventListener('click', togglePause);
    btnWrap.addEventListener('click', toggleWrap);
    btnReset.addEventListener('click', resetGame);

    function startGame() {
      if (state.running && !state.paused) return;
      state.running = true;
      state.paused = false;
      state.lastTime = performance.now();
      state.frameAccumulator = 0;
      btnPause.textContent = 'Pause';
      requestAnimationFrame(loop);
    }

    function togglePause() {
      if (!state.running) return;
      state.paused = !state.paused;
      btnPause.textContent = state.paused ? 'Resume' : 'Pause';
      if (!state.paused) {
        state.lastTime = performance.now();
        requestAnimationFrame(loop);
      }
    }

    function toggleWrap() {
      state.wrap = !state.wrap;
      wrapEl.textContent = state.wrap ? 'ON' : 'OFF';
    }

    // ---------- Game loop ----------
    function loop(now) {
      if (!state.running) return;
      const dt = (now - state.lastTime) / 1000; // seconds
      state.lastTime = now;

      if (!state.paused) {
        // Advance accumulator by dt * fps
        const stepInterval = 1 / state.speed; // seconds per movement
        state.frameAccumulator += dt;

        // we allow multiple steps if lagging
        while (state.frameAccumulator >= stepInterval) {
          step(); // discrete grid movement
          state.frameAccumulator -= stepInterval;
        }

        // draw with interpolation for smooth movement
        render(state.frameAccumulator / stepInterval);
      } else {
        // if paused, still draw subtle overlay
        render(0);
      }

      if (state.running && !state.paused) {
        requestAnimationFrame(loop);
      }
    }

    // ---------- Game step (moves snake by 1 grid cell) ----------
    function step() {
      // update direction from buffered input
      state.dir = { ...state.nextDir };

      // compute new head (integer)
      const head = state.snake[0];
      let nx = head.x + state.dir.x;
      let ny = head.y + state.dir.y;

      // wrap or collision with border
      if (state.wrap) {
        if (nx < 0) nx = state.cols - 1;
        if (nx >= state.cols) nx = 0;
        if (ny < 0) ny = state.rows - 1;
        if (ny >= state.rows) ny = 0;
      } else {
        if (nx < 0 || ny < 0 || nx >= state.cols || ny >= state.rows) {
          gameOver();
          return;
        }
      }

      // check self-collision
      // snake positions are integers here
      if (state.snake.some((s, idx) => idx !== state.snake.length - 1 && s.x === nx && s.y === ny)) {
        gameOver();
        return;
      }

      // insert new head
      state.snake.unshift({ x: nx, y: ny });

      // did we eat apple?
      if (nx === state.apple.x && ny === state.apple.y) {
        state.score += config.scorePerFood;
        // level up roughly every 50 points, increase speed
        const newLevel = Math.floor(state.score / 50) + 1;
        if (newLevel > state.level) {
          state.level = newLevel;
          state.speed = Math.min(60, state.speed * config.speedIncreasePerLevel);
        }
        // place new apple
        state.apple = randomEmptyCell();
      } else {
        // remove tail
        state.snake.pop();
      }

      updateHUD();
    }

    function gameOver() {
      state.running = false;
      state.paused = false;
      btnPause.textContent = 'Pause';
      // flash effect and reset some UI
      flashCanvas('rgba(255,40,40,0.12)', 220);
    }

    // ---------- Rendering ----------
    function clearCanvasFull() {
      ctx.fillStyle = '#050607';
      ctx.fillRect(0, 0, canvas.width / DPR, canvas.height / DPR);
    }

    // Draw a decorative neon grid background (subtle)
    function drawGridBackground() {
      const w = canvas.width / DPR;
      const h = canvas.height / DPR;
      // base dark fill
      ctx.fillStyle = '#020405';
      ctx.fillRect(0, 0, w, h);

      // grid lines
      ctx.save();
      ctx.globalAlpha = 0.12;
      ctx.strokeStyle = '#00ff9a';
      ctx.lineWidth = 1;
      // compute cell + gap step
      const stepX = state.cellSize + config.cellGap;
      const stepY = state.cellSize + config.cellGap;
      // offset to center
      const ox = state.offsetX;
      const oy = state.offsetY;
      for (let i = 0; i <= state.cols; i++) {
        const x = Math.round(ox + i * stepX) + 0.5;
        ctx.beginPath();
        ctx.moveTo(x, oy);
        ctx.lineTo(x, oy + state.rows * stepY);
        ctx.stroke();
      }
      for (let j = 0; j <= state.rows; j++) {
        const y = Math.round(oy + j * stepY) + 0.5;
        ctx.beginPath();
        ctx.moveTo(ox, y);
        ctx.lineTo(ox + state.cols * stepX, y);
        ctx.stroke();
      }
      ctx.restore();
      // slight vignette
      const g = ctx.createLinearGradient(0, 0, 0, h);
      g.addColorStop(0, 'rgba(0,0,0,0.1)');
      g.addColorStop(1, 'rgba(0,0,0,0.22)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);
    }

    // Render the whole scene with interpolation (0..1)
    function render(alphaInterp = 0) {
      // Fade previous frame slightly to create glow trail effect
      ctx.fillStyle = `rgba(2,4,6, ${config.trailFade})`;
      ctx.fillRect(0, 0, canvas.width / DPR, canvas.height / DPR);

      // draw background grid faintly
      drawGridBackground();

      // draw apple (red apple with shine)
      drawApple(state.apple);

      // draw snake with smooth interpolation between previous and current positions
      drawSnake(alphaInterp);

      // optional: HUD overlay effects are handled by HTML elements
    }

    // convert grid coordinate to pixel center of cell
    function cellCenter(x, y) {
      const step = state.cellSize + config.cellGap;
      const cx = state.offsetX + x * step + state.cellSize / 2;
      const cy = state.offsetY + y * step + state.cellSize / 2;
      return { cx, cy };
    }

    // Draw snake using rounded capsules and glow
    function drawSnake(alpha) {
      ctx.save();
      // glow layer
      ctx.shadowColor = 'rgba(0,255,140,0.28)';
      ctx.shadowBlur = 22;
      ctx.globalCompositeOperation = 'lighter';

      // iterate segments and draw circles/caps
      for (let i = 0; i < state.snake.length; i++) {
        const seg = state.snake[i];
        // next position for head interpolation
        let nextPos = seg;
        if (i === 0 && state.running) {
          // head's previous position is second element for interpolation, if exists
          if (state.snake.length > 1) {
            const follow = state.snake[1];
            const interpX = seg.x * 1 - (seg.x - follow.x) * alpha;
            const interpY = seg.y * 1 - (seg.y - follow.y) * alpha;
            nextPos = { x: interpX, y: interpY };
          }
        }

        const { cx, cy } = cellCenter(nextPos.x, nextPos.y);
        const radius = state.cellSize * 0.46;

        // draw glow outer
        ctx.fillStyle = `rgba(0,255,140, ${0.045 + (1 - i / state.snake.length) * 0.18})`;
        ctx.beginPath();
        ctx.arc(cx, cy, radius * 1.7, 0, Math.PI * 2);
        ctx.fill();

        // core body circle
        ctx.fillStyle = `rgba(0,250,150, ${0.48 + (1 - i / state.snake.length) * 0.35})`;
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.fill();

        // inner bright core
        ctx.fillStyle = '#baffd8';
        ctx.globalAlpha = 0.12 + (1 - i / state.snake.length) * 0.65;
        ctx.beginPath();
        ctx.arc(cx - radius * 0.3, cy - radius * 0.3, radius * 0.45, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      // head highlight (clearer)
      const head = state.snake[0];
      const center = cellCenter(head.x, head.y);
      ctx.shadowBlur = 28;
      // head radial gradient
      const g = ctx.createRadialGradient(center.cx - 6, center.cy - 6, 2, center.cx, center.cy, state.cellSize);
      g.addColorStop(0, 'rgba(255,255,255,0.8)');
      g.addColorStop(0.05, 'rgba(200,255,230,0.9)');
      g.addColorStop(0.15, 'rgba(0,255,140,0.8)');
      g.addColorStop(1, 'rgba(0,255,140,0.06)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(center.cx, center.cy, state.cellSize * 0.52, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    // Draw apple shape with small leaf and shine
    function drawApple(cell) {
      if (!cell) return;
      ctx.save();
      const { cx, cy } = cellCenter(cell.x, cell.y);
      const R = state.cellSize * config.appleRadiusPct;

      // main body glow
      ctx.shadowBlur = 22;
      ctx.shadowColor = 'rgba(255,60,60,0.28)';
      ctx.fillStyle = 'rgba(255,60,60,0.95)';
      ctx.beginPath();
      ctx.ellipse(cx, cy, R, R * 0.92, 0, 0, Math.PI * 2);
      ctx.fill();

      // inner gradient
      const g = ctx.createLinearGradient(cx - R, cy - R, cx + R, cy + R);
      g.addColorStop(0, '#ff8a8a');
      g.addColorStop(0.45, '#ff2b2b');
      g.addColorStop(1, '#b30000');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.ellipse(cx, cy, R * 0.88, R * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();

      // shine
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.globalAlpha = 0.14;
      ctx.beginPath();
      ctx.ellipse(cx - R * 0.35, cy - R * 0.45, R * 0.45, R * 0.25, -0.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // small stem
      ctx.fillStyle = '#603020';
      ctx.fillRect(cx + R * 0.26, cy - R * 0.95, R * 0.12, R * 0.36);
      // leaf
      ctx.fillStyle = '#2fb84c';
      ctx.beginPath();
      ctx.ellipse(cx + R * 0.42, cy - R * 0.95, R * 0.22, R * 0.12, -0.9, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    // small flash overlay on game over
    function flashCanvas(color, duration = 200) {
      const w = canvas.width / DPR;
      const h = canvas.height / DPR;
      // draw once then fade
      const start = performance.now();
      function tick(t) {
        const elapsed = t - start;
        const progress = Math.min(1, elapsed / duration);
        // overlay with decreasing alpha
        ctx.save();
        ctx.fillStyle = color;
        ctx.globalAlpha = 1 - progress;
        ctx.fillRect(0, 0, w, h);
        ctx.restore();
        if (progress < 1) requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    }

    // ---------- HUD update ----------
    function updateHUD() {
      scoreEl.textContent = String(state.score);
      levelEl.textContent = String(state.level);
      spdEl.textContent = state.running ? String(Math.round(state.speed)) : 'Normal';
      wrapEl.textContent = state.wrap ? 'ON' : 'OFF';
    }

    // ---------- Window resizing handler ----------
    function onResize() {
      resizeCanvasToContainer();
      drawGridBackground();
      render(0);
    }
    window.addEventListener('resize', onResize);

    // Initialize everything once DOM is ready
    (function init() {
      // Make canvas focusable so keyboard works when clicked
      canvas.addEventListener('click', () => canvas.focus());
      // Initial sizing and game reset
      resizeCanvasToContainer();
      resetGame();
      // Pre-draw a static scene
      render(0);

      // small animation to show glowing grid on load
      setTimeout(() => {
        btnStart.textContent = 'Start';
      }, 300);

      // Accessibility: focus canvas to capture arrow keys by default
      setTimeout(() => { try{ canvas.focus(); } catch(e){} }, 600);
    })();
  </script>
</body>
</html>
